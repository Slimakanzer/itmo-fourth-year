# 1 Понятие тестирование ПО. Основные определения.

Тестирование - одна из техник контроля качества ПО, которая проверяет соответсвие между ожидаемым и реальным поведением ПО. Нужна для повышения пользовательского доверия в корректности работы ПО. Включает в себя Test Management, Test Design, Test Execution, Test Analysis.

* Mistake - просчёт, ошибка человека
* Fault - дефект, изъян
* Failure - отказ, сбой
* Error - невозможность выполнить задачу впоследствие отказа
* Валидация - корректное ли ПО?
* Верификация - на сколько корректно работает ПО?

`План Тестирования` - документ, описывающий весь объем работ по тестированию, начиная с описания объекта, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков с вариантами их разрешения.

# 2 Цели и принципы тестирования.

## Цели
* Обнаружение дефектов
* Предотвращение дефектов
* Повышение качества продукта
* Повышение пользовательского доверия
* Предоставление информации для принятия решений

## Принципы ISTQB
1. **Тестирование показывает наличие дефектов, а не их отсутсвие.** Важно составлять тесткейсы, которые будут находить как можно больше дефектов, благодаря чему может снизится вероятность наличия ошибок.

2. **Необходимо раннее тестирование.** Тестирование продукта необходимо начинать как можно раньше в жизненном цикле ПО, начиная ещё со статичесткого тестирования.

3. **Исчерпывающее тестирование невозможно.** В реальном ПО невозможно протестировать все возможные комбинации и состояния.

4. **Заблуждение об отсутствии ошибок.** Как уже говорилось, тестирование показывает наличие дефектов, а не их отсутствие. Если тесты прошли успешно - это не значит отсутствие ошибок.

5. **Скопление дефектов.** Модули ПО могут содержать разное количество дефектов, поэтому важно пропорционально распределять ресурсы тестирования, ориентируясь на их плотность скопления. Также дефекты имеют свойство скапливаться в некотором маленьком множестве модулей. Принцип Парето гласит, что 80% дефектов сосредоточены в 20% модулей.

6. **Парадокс пестицида.** В процессе разработки ПО отлавливаются дефекты и исправляются, таким образом, тесты находят всё меньше и меньше дефектов. Поэтому важно обновлять и следить за состоянием тесткейсов, рецензировать и корректировать.

7. **Тестирование зависит от контекста.** Методология, техники и типы тестирования будет зависить напрямую от природы ПО. Если сравнивать ПО для медицины и ПО для какого-нибудь сайта.

# 3 Основная цель тестирования. Уровень доверия, корректное поведение, реальное окружение.
Цель тестирование - повышение пользовательского доверия в корректности работы ПО в условиях реальной эксплуатации.

## Уровень доверия
Тестирование как один из способов повысить доверие.
* Количество выявленных дефектов тестами
* Количество выявленных дефектов в период времени

Также можно убедить пользователя в работоспособности ПО с помощью требований к надежности. Однако это требует долгой работы уже готового ПО в реальном окружении.
* ПО безоткзазно в течении 1000 часов.

## Реальное окружение
Тесты также должны проходить на наиболее приближенной к реальной аппаратуре, должны проходить в целевых условиях эксплуатации и также должны быть использованы как можно более реалистичные входные данные.

# 4 Тестирование и качество. Уровни восприятия тестирования в компании.

Способы оценки качества ПО:
* Тестирование
* Внешние и внутреннии стандарты
* Обучение
* Анализ дефектов (поиск истинной причины)

Уровни восприятия:

0. Тестирование и дебаг не отличаются. Это для глупых.
1. Тестирование как способ показать корректность работы ПО. Тяжело оценить количество тестов.
2. Тестирование как способ поиска дефектов. Неизбежна война между разрабами и тестерами.
3. Тестирование как способ показать наличие дефектов. Команда желает снизить риски использования ПО. Риски могут быть как критические, так и нет, но они всегда есть.
4. Тестирование как способ оценки качества ПО в терминах найденных дефектов.

# 5 Участники тестирования, их роль, квалификация и обязанности.

## Проектировщик тестов
Разрабатывают тесты. Они должны обладать знанием предметной области, экспертиза. Обладают знанием формальных критериев и умеют их применять.

## Автоматизация тестов
Написание скриптов для автоматизации тестов. Знания средств/скриптов.

## Исполнение тестов
Запуск и ручной поиск тестов. Они должны знать систему, требования.

## Анализ тестов
Они должны анализировать результат тестов для интерпретирования этих результатов. Они должны знать предметную область.

## Роли в формальном статическом тестировании
* Менеджер
* Модератор - нужен для выбора среднего
* Докладчик - ведущий человек, который оглашает список проверки, желательно не имеющий дело к проекту
* Автор
* Эксперт - эксперты в узкой области
* Секретарь

# 6 Мониторинг прогресса и контроль тестирования (ISTQB)

`Мониторинг прогресса` - необходим для предоставление результата и обзора процесса тестирования. Метрики могут быть использованы для оценки прогресса тестирования по сравнению с запланированным расписанием и бюджетом. Могут быть использованы такие метрики: покрытие, количество открытых багов, плотность дефектов, количество найденых, исправленных дефектов. Информация о результате тестов может быть собрана автоматически или вручную.

`Контроль тестирования` - описывает направляющие или корректирующие действия, принятые как результат по полученной информации и значениям метрик для достижения наилучшего возможного результата для проекта. Контроль тестирования может затрагивать любые действия по тестированию, а также воздействовать на задачи жизненного цикла ПО.

# 7 Модульное тестирование. Понятие модуля. Драйверы и заглушки.

Модульное тестирование - тестирование отдельных компонентов ПО. Модуль - элемент декомпозиции системы. Модули могут быть описаны в дизайне/требованиях.

* Драйвер - вместо вызывающего модуля
* Заглушка - вместо подчиненного модуля

Драйвер - более сложная программа, которая также могёт запускать серию тестов, настраивать заглушки, формировать журнал результатов.
Заглушка - простой функционал, иногда может иметь особое поведение для теста. Эмулирует поведение вызываемого функционала.

# 8 V-образная модель. Статическое и динамическое тестирование.

Это условная модель жизненного цикла проекта, которая является улучшенной версией **модели водопада**. Главная проблема в **модели водопада** является то, что тестирование начинается уже ***после завершения реализации***. **V-модель** решает данную проблему тем, что тестирование начинается уже с этапа требований и каждый уровень имеет своей тестовый план. **V-модель** особенно хороша для проектов, которым особенно важно бесперебойное функционирование.

Можно условно разделить модель на две часли - слева **V-модели** происходит статическое тестирование, справа - динамическое тестирование.

![v-model](resources/v-model.PNG)

`Статическое тестирование` – тип тестирования, который предполагает, что программный код во время тестирования не будет выполняться. При этом само тестирование может быть как ручным, так и автоматизированным.

`Динамическое тестирование` – тип тестирования, который предполагает запуск программного кода. Таким образом, анализируется поведение программы во время ее работы.

# 9 Валидация и верификация. Тестирование методом "чёрного" и "белого" ящика.

- `Валидация` - проверка соответсвия ПО ожиданиям и потребностям пользователей.
- `Верификация` - проверка соответствия ПО спецификациям (функционал).

- Метод чёрного ящика (black-box) - техника тестирования на основе анализа спецификации без сылки на внутренне устройство компонента/системы.
- Метод белого ящика (white-box) - тестирование на основе анализа внутреннего устройсва компонента/системы.

# 10 Тестовый случай, тестовый сценарий и тестовое покрытие.
`Тестовый случай` (Test Case) - набор предусловий, условий, входных данных, ожидаемых результатов, постусловий. Должен быть повторяемым. Должны быть определы правильный ожидаемый результат. Если проверяется на ошибку, то должны быть корректные сообщения об ошибке.

`Тестовый сценарий` - последовательность тестовых случаев, проверяется типичное использование системы. Должно проверяться как корректное поведение, так и нет. Требования к поведению описываются в требованиях, архитектуре и проектных документах.

`Тестовое покрытие` - метрика плотности покрытия тестами требований либо исполняемого кода ПО.

# 11 Полное тестовое покрытие. Оценка объема и времени полного покрытия.
В реальных проектах полное тестовое покрытие - недостижимая цель.

Очевидно объем для полного покрытия даже умножения - нереальная вещь. И время - очень долго.

- `Path testing` - это метод тестирования, которое проверяет все возможные пути исполнения программы. Однако реальное ПО содержит огромное множество путей, которое очень долго и тяжело протестировать.
- `Basis Path testing` - это метод тестирования, которое проверяет все возможные независимые логические пути программы.

# 12 Повторяемость тестового сценария. Автоматизированное тестирование. Регрессионное тестирование.
Тестовые сценарии должны быть повторяемые.

* Автоматизированное тестирование - тестирование с использованием специальных средств, которые запускают тесты. 
* Регрессионное тестирование - тестирование новых изменений в проекте для проверки того, что изменения не повлияли на существующий функционал.

# 13 Цели и задачи интеграционного тестирования. Алгоритм интеграционного тестирования. Стратегии интеграции.

Интеграционное тестирование - тестируется взаимодействие модулей между собой, а также интеграция подсистем в одну общую систему. Для этого вида тестирования необходимо как минимум два готовых модуля. Выполняется после модульного тестирования.

Стратегии:
1. Сверху-вниз - идут с самых высокоуровневых модулей к самым изкоуровневым. Быстро появляется осязаемость приложения, можно уже тестировать время отклика, однако большое количество заглушек.
2. Снизу-вверх - с самых низкоуровневых модулей к высокоуровневым по мере готовности. Меньшее количество зашлушек.
3. End-to-end (функциональное) - тестирование пользовательских сценариев.
4. Backbone - собирают все основные модули ПО, их тестируют, а затем по мере готовности добавляют остальные.
5. Big-bang - собирают все модули в виде готовой системы и тестируют их.

# 14 Тестирование системы целиком - системное тестирование.
Системное тестирование - тестирование системы целиком с целью проверки на соответсвие установленным требованиям. Выполняется после окончания интеграции.

Состит из 4-х этапов:
1. Системное тестирование - тестирование пользовательских сценариев. Тестирование производится со стороны разработчиков. Окружение должно быть максимально приближено к реальному, скрипты исполняют реальные сценарии.
2. Альфа-тестирование - совместное тестирование пользователей и разработчиков. Может быть реализован не весь функционал.
3. Бета-тестирование - тестирование выбранной группой пользователей. Может быть реализован не весь функционал.
4. Приемочное тестирование - тестирование со стороны заказчиков на основе договора/требований.

# 15 Тестирование возможностей, стабильности, отказоустойчивости, совместимости.
1. Возможность (один пользователь, одна транзакиця, среднее аппаратное обеспечение, идеальные переходы между состояниями, положительные сценарии)
2. Стабильность (валидные данные, несколько пользователей, реальные последовательности транзакций, длительное время)
3. Устойчисвость к сбоям (невалидные данные, неправильные переходы, сбои в сети, аварийное отключение)
4. Совместимость (проверка функционирования в различных средах, ОС, браузера и т.д.)
5. Производительность:
    * Capacity      - пределы системы (макс количество пользователей и т.п.)
    * Accuracy      - точность (CNN)
    * Response time - время отклика. Очень важно для систем реального времени (тестируется под минимальной, рассчётной и пиковой нагрузке)
    * Availability  - готовность (коэффициент готовности, сколько процентов относительно времени будет стабильно работать)
    * Through       - пропускная способность (количество операций в секунду), стресстестирование

# 16 Тестирование производительности – CARAT
Производительность ***CARAT***:
* Capacity      - пределы системы (макс количество пользователей, частота, файлов и т.п.)
* Accuracy      - точность (CNN)
* Response time - время отклика. Очень важно для систем реального времен (тестируется под минимальной, рассчётной и пиковой нагрузке)
* Availability  - готовность (коэффициент готовности, сколько процентовотносительно времени будет стабильно работать)
* Through       - пропускная способность (количество операций в секунду), стресстестирование

# 17 Альфа и Бета тестирование. Приемочное тестирование.

## Альфа тестирование
Тестирование на пользователях совместно с разработчиками. Можно запускать до завершения системного тестирования.

## Бета тестирование
Тестирование выбранной группой пользователей. Могут быть ошибки и может быть реализован весь функционал.

## Приемочное тестирование
Происходит на основе догвора/требований на стороне заказчика. Может быть как формальное и неформальное тестирование. Производится как функциональное и нефункциональное тестирование.

# 18 Статическое тестирование. Рецензия, технические анализ, сквозной контроль.
Плюсы статического тестирования:
* Может проводиться на ранних стадиях ЖЦ ПО
* Снижает стоимость рисков
* Объектом является техническое задание, спецификации, планы, стратегии

## Рецензия
Неформальное тестирование, взгляд со стороны. Например, со стороны коллег.

## Технический анализ
Участники анализируют технические документы, предварительно готовят комментарии. Подгатавливают альтернативы и рекомендации.

## Сквозной контроль
Аудитория слушает автора, задают комментарии, находят ошибки, аномалии, неэффективности, проблемы интерфейсов, отклонение от практик.
Может проводится с образовательными целями.

# 19 Статическое тестирование. Инспекции.
Это наиболее формальный вид тестирования, для которой компании нанимают специалистов. Целью инспекции является обнаружить и идентифицировать аномалии ПО и предоставить рекомендации. Также позволяет обмениваться знаниями.

В инспекции чётко определены документы, которые будут проходить инспекцию, роли каждого человека, входные и выходные критерии, а также время (check rate).

Роли инспекции:
* Чеклист — инспектор проверят по нему
* Документы — инспектор проверяет целостность между несколькими документами
* Фокус — поиск выделенных проблем
* Перспектива — представить роль пользователя
* Процедура — инспектор следует особой процедуре
* Сценарий — следование заданному сценарию (более специфично, чем предыдущий)
* Стандарт — проверка на соответствие стандартам
* Точка зрения — инспектирует с т.з. некоторого пользователя


Инспекция содержит 8 этапов:
1. Вход - что хотим достичь
2. Планирование - расписание, собираемые метрики
3. Обзор - обучение инспекторов, назначение ролей, распространение материалов
4. Подготовка - инспекторы проверяют на артефакты в соответствии с ролью (отмечают время начала, время конца, класс проблемы)
5. Обсуждение - протоколирование результатов подготовки, ведущий краток и не позволяет создавать долгую дискуссию
6. Переработка - перерабатываются не принятые артефакты, инспекция не завершается до тех пор, пока не удовлетворит выходным критериям
7. Выработка рекомендаций
8. Выход

# 20 Статическое тестирование. Статический анализ кода.
Позволяет находить дефекты на ранних стадиях, снижает риски. Средства статического анализа позволяют находить:
* Нарушение алгоритмов использования библиотеки
* Сценарии некорректного поведения
* Переполнение буфера
* Разрушение кроссплатформенности
* Дефекты копи-пейста
* Мертвый код
* и многое другое

Пример: PVS-studio, intellij idea

# 21 Выбор тестового покрытия с помощью анализа эквивалентности. Анализ граничных значений.
Анализ эквивалентности - это техника, в которой производится тестирование набора классов эквивалентности. Класс эквивалентности - это результат разбиения множества входных данных на эквивалентные по взаимодействию группы.

Анализ граничных значений - это техника, направленная на тестирование граничных значений входных данных. Например, граничных значений классов эквивалентности. Ведь на границах очень часто возникают дефекты. Необходимо проверить значение до границы, саму границу и значение после границы.

# 22 Выбор тестового покрытия с помощью таблицы решений.
Таблица решений - это техника тестирования, в которой проверяется набор комбинаций входных значений и реакции системы. Она предоставляет чёткий метод прверки всех комбинаций системы.

Input | case 1 | case 2 | case 3
--- | --- | --- | ---
Входное условие 1 | Y | Y | N
Входное условие 2 | Y | N | N
Входное условие 3 | N | N | N
**Output** | | |
Выходное действие 1 | X | |
Выходное действие 2 | | | X
Выходное действие 3 | | X |

# 23 Выбор тестового покрытия с помощью диаграммы состояний и таблицы переходов.
Диаграмма состояний - выделяются состояния сущности, затем строится граф переходов между состояниями. На основе этого графа строятся тесты как на допустимые переходы, так и на недопустимые.

Таблица переходов - декартово произведение состояний сущности и возможных действий

state | | conditions | current state | current condition | action | result state
--- | --- | --- | --- | --- | --- | ---
 -- | -- | -- | state 1 | Click btn | Show window | state 2
 -- | -- | -- | state 1 | Fill form | Not defined | Not defined
state 1 | -- | Click btn | state 1 | Click login | Show error | state 1
state 2 | X | Fill form | state 2 | Click btn | Not defined | Not defined
 -- | -- | Click login | state 2 | Fill form | Close form | state 2
 -- | -- | -- | state 2 | Click login | Login | state 1

# 24 Выбор тестового покрытия с помощью функционального тестирования.
Тестирование на основе пользовательского сценария. Готовяться входные данные для проверки сценария, может быть несколько таких проверок.

Прецендент | ShowUserView
--- | ---
ID | 1
Описание | Показать пользовательское окно
Главный актёр | пользователь
Второстепенный актер | нет
Предусловия | пользователь залогинился
Основной поток | при нажатии кнопки "моё меню"

# 25 Библиотека JUnit. Класс junit.framework.Assert
JUnit - это фреймворк семейства xUnit для модульного тестирования. Дает возможность написать тест, который будет запущен. Содержит конфигурирование тестов, форматированный вывод результатов тестов и набор утверждений (Assert).

`junit.framework.Assert` - класс, который содержит набор статических методов для проверки некоторых утверждений. Если проверку не прошло, то завершает тест и выводит сообщение в вывод. Пример утверждений Assert:
* assert[Not]Equals
* assert[Not]Null
* assertArrayEquals
* assertTrue
* assertFalse
* assertSame
* assertThat

```java
public class TestExample {
    private static ExampleClass example;

    @BeforeClass public static void setup(){
        example = new ExampleClass();
    }

    @Test public void testExample(){
        assertEquals(12, example.magickNumber());
    }
}
```

# 26 Библиотека JUnit. Основные аннотации для исполнения тестов.
* `@Before` – помечается метод перед исполнением каждого теста. Аналог – название setUp().
* `@After` – после исполнения каждого теста. Аналог – название tearDown().
* `@Test(expected = throwable, timeout = long)` – и в Африке тест. Есть 2 параметра: expected – какое исключение ожидать и timeout – сколько тест должен максимум работать.
* `@BeforeClass` и `@AfterClass` – методы до и после исполнения тестов класса.
* `@Ignore` – пропустить тест.
* `@Parameters` - параметризированный тест

```java
@RunWith(Parameterized.class)
public class TestExample {
    private static ExampleClass example;
    private final int value;

    @Parameters(name = "value")
    public static Collection<Integer> data() {
        return Arrays.asList(1, 2, 3, 4);
    }

    public TestExample(int value){
        this.value = value;
    }

    @BeforeClass public static void setup(){
        example = new ExampleClass();
    }

    @Test public void testExample(){
        assertEquals(value, example.magickNumber());
    }
}
```

# 27 Библиотека JUnit. Дополнительные возможности, запуск с параметрами.
* `@RunWith` - запускает не дефолтный JUnit runner, а указанный в аннотации
* `@SuiteClasses` - позволяет объединить несколько классов тестов в одно место и запустить их вместе
* `@Parameterized` - параметризированный тест

Это паста с прошлого вопроса:
```java
@RunWith(Parameterized.class)
public class TestExample {
    private static ExampleClass example;
    private final int value;

    @Parameters(name = "value")
    public static Collection<Integer> data() {
        return Arrays.asList(1, 2, 3, 4);
    }

    public TestExample(int value){
        this.value = value;
    }

    @BeforeClass public static void setup(){
        example = new ExampleClass();
    }

    @Test public void testExample(){
        assertEquals(value, example.magickNumber());
    }
}
```

# 28 Анализ эквивалентности с использованием JUnit.
Проверяем каждый класс внутри, проверяем каждую границу, проверяем вне классов.

```java
/**
 * (-inf; -1) false
 * [-1; -0.1] true
 * [0.1; 3] true
 * (3; +inf) false
 */
class SomeFunction{
    boolean calc(float x) {
        if (x < -1 || x > 3) return false;
        if (x > -0.1 && x < 0.1) throw new RuntimeException("wrong");
        return true;
    }
}


public class TestEquivalenceAnalysis {
    private static SomeFunction function;

    @BeforeClass public static void setup(){
        function = new SomeFunction();
    }

    @Test public void testLeftSideOutside(){
        assertFalse(function.calc(-10.0f));
        assertFalse(function.calc(-9.0f));
        assertFalse(function.calc(-2.0f));
    }

    @Test public void testLeftBorder(){
        assertFalse(function.calc(-1.1f));
        assertTrue(function.calc(-1.0f));
        assertTrue(function.calc(-0.9f));
    }

    @Test public void testLeftSideInside(){
        assertTrue(function.calc(-0.5f));
        assertTrue(function.calc(-0.4f));
        assertTrue(function.calc(-0.3f));
    }

    @Test(expected = RuntimeException.class) public void testLeftEmptyBorder(){
        assertTrue(function.calc(-0.2f));
        assertTrue(function.calc(-0.1f));
        function.calc(-0.0f);
    }

    @Test(expected = RuntimeException.class) public void testRightEmptyBorder(){
        assertTrue(function.calc(0.2f));
        assertTrue(function.calc(0.1f));
        function.calc(-0.0f);
    }

    @Test public void testRightSideInside(){
        assertTrue(function.calc(0.5f));
        assertTrue(function.calc(1.0f));
        assertTrue(function.calc(2.0f));
    }

    @Test public void testRightBorder(){
        assertTrue(function.calc(2.9f));
        assertTrue(function.calc(3.0f));
        assertFalse(function.calc(3.1f));
    }

    @Test public void testRightSideOutside(){
        assertFalse(function.calc(3.2f));
        assertFalse(function.calc(4.0f));
        assertFalse(function.calc(7.0f));
    }
}
```

# 29 Тестирование алгоритмов с использованием JUnit.
Можно использовать таблицу решений. То есть тестами будет декартово произведение состояний и возможных действий.
В данном примере приведен алгоритм тестирования бинарного дерева. Есть действие создать дерево, добавить больший элемент, добавить меньший элемент. Состояния: дерево отсутсвует, есть левый элемент у дерева, есть правый элемент у дерева, есть оба элемента у дерева.

```java
class Tree<T extends Comparable<T>> {
    public Tree<T> left;
    public Tree<T> right;
    public T key;
    public int level;

    public Tree(T k) {
        key = k;
        level = 0;
    }

    private Tree(T k, int l) {
        key = k;
        level = l;
    }

    public void insert(T key) {
        if (key.compareTo(this.key) < 0) {
            if (left != null) left.insert(key);
            else left = new Tree<>(key, level+1);
        } else {
            if (right != null) right.insert(key);
            else right = new Tree<>(key, level+1);
        }
    }

    public void traverse(TreeVisitor<T> visitor) {
        if (left != null)
            left.traverse( visitor );

        visitor.visit(this);

        if (right != null )
            right.traverse( visitor );
    }
}

interface TreeVisitor<T extends Comparable<T>> {
    void visit(Tree<T> node);
}

class TreePair<T extends  Comparable<T>>{
    public T key;
    public int value;

    public TreePair(T k, int v){
        key = k;
        value = v;
    }
}

class KeyPrinter<T extends Comparable<T>> implements TreeVisitor<T> {
    private final List<TreePair<T>> data;

    public KeyPrinter(){
        data = new LinkedList<>();
    }

    public List<TreePair<T>> getData(Tree<T> tree) {
        tree.traverse(this);
        return data;
    }

    public void visit(Tree<T> node) {
        data.add(new TreePair<>(node.key, node.level));
    }
}

public class TestAlgorithm {
    private Tree<Integer> tree;
    private KeyPrinter<Integer> visitor;

    @Before public void setup(){
        visitor = new KeyPrinter<>();
    }

    @Test public void testInsertFirstElement(){
        tree = new Tree<>(1);

        assertEquals(Arrays.asList(new TreePair<>(1, 0)), visitor.getData(tree));
    }

    @Test public void testInsertLowerThanElement(){
        tree = new Tree<>(1);
        tree.insert(0);

        assertEquals(Arrays.asList(new TreePair<>(0, 1), new TreePair<>(1, 0)), visitor.getData(tree));
    }

    @Test public void testInsertGreaterThanElement(){
        tree = new Tree<>(1);
        tree.insert(3);

        assertEquals(Arrays.asList(new TreePair<>(1, 0), new TreePair<>(3, 1)), visitor.getData(tree));
    }
}
```

# 30 Модульное тестирование доменной модели с использованием JUnit.
Декомпозируем ПО на отдельные модули и тестируем их. Для создания затычек можно использовать библиотеку Mockito.

```java
@BeforeClass public static void setup(){
    exampleClass = Mockito.mock(ExampleClass.class);

    Mockito.when(exampleClass.magicMethod(1)).thenReturn(true);
    Mockito.when(exampleClass.magicMethod(2)).thenReturn(true);
    Mockito.when(exampleClass.magicMethod(3)).thenThrow(new Exception("looser"));
}

@Test public void testExample(){
    assertTrue(exampleClass.magicMethod(1));
    assertTrue(exampleClass.magicMethod(2));
    assertTrue(exampleClass.magicMethod(2));

    Mockito.verify(exampleClass, Mockito.times(3)).getDataById(Mockito.any());
    Mockito.verify(exampleClass, Mockito.times(1)).getDataById(1);
    Mockito.verify(exampleClass, Mockito.times(2)).getDataById(2);
    Mockito.verify(exampleClass, Mockito.never()).getDataById(3);
    Mockito.verifyNoMoreInteractions(exampleClass);
}
```